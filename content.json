{"meta":{"title":"Maple's Blog","subtitle":null,"description":null,"author":"maple.yf","url":"http://blog.maple-yf.com"},"pages":[{"title":"Hello World","date":"2017-08-27T05:21:57.000Z","updated":"2020-03-05T03:55:35.782Z","comments":false,"path":"about/index.html","permalink":"http://blog.maple-yf.com/about/index.html","excerpt":"","text":"生活不止眼前的苟且，还有诗和远方的田野。 努力做一个生活有烟火气，灵魂有香气的孩子。"},{"title":"Categories","date":"2017-08-20T16:09:17.000Z","updated":"2020-03-05T03:55:35.782Z","comments":false,"path":"categories/index.html","permalink":"http://blog.maple-yf.com/categories/index.html","excerpt":"","text":"PoetryTech"},{"title":"Tags","date":"2017-08-20T15:51:50.000Z","updated":"2020-03-05T03:55:35.783Z","comments":false,"path":"tags/index.html","permalink":"http://blog.maple-yf.com/tags/index.html","excerpt":"","text":"PoetryWebpackJekyllSSDShadowSocksUbuntuVS CodeWindowsUMLAuto TestITCSSNodeJavaScriptReact"}],"posts":[{"title":"软件开发生命周期","slug":"2018-01-20-introduction-of-softweare-release-lifecycle","date":"2018-01-19T16:00:00.000Z","updated":"2020-03-05T04:17:53.612Z","comments":true,"path":"2018/01/20/2018-01-20-introduction-of-softweare-release-lifecycle/","link":"","permalink":"http://blog.maple-yf.com/2018/01/20/2018-01-20-introduction-of-softweare-release-lifecycle/","excerpt":"","text":"前言最近研究React的时候，看到这样一个版本号 React 16 RC，非常疑惑，不知道这里的RC到底是什么意思。 软件版本周期查了相关资料才知道，这个和软件版本周期有关，然后在Wikipedia里找到了这张图，这是经过优化过的，原图比较丑^_^。 从图中可以看到，软件的整个版本周期包括两个大的部分：开发测试阶段和发布阶段。 开发测试阶段有我们比较熟悉的alpha、beta，以及在此之前的pre-alpha和在此之后的release candidate，也就是前言里提到的RC版本。 在发布阶段，又有RTM、GA以及Production等版本阶段。 开发测试阶段Pre-alpha有时候软件会在Alpha或Beta版本前先发布Pre-alpha版本。一般而言相对于Alpha或Beta版本，Pre-alpha版本是一个功能不完整的版本。 Alpha (内部测试版)Alpha版本仍然需要测试，其功能亦未完善，因为它是整个软件发布周期中的第一个阶段，所以它的名称是“Alpha”，希腊字母中的第一个字母“α”。这个版本一般不会对外发布。 Alpha版本通常会送到开发软件的组织或某群体中的软件测试者作内部测试。在市场上，越来越多公司会邀请外部客户或合作伙伴参与其测试。这令软件在此阶段有更大的可用性测试。 在测试的第一个阶段中，开发者通常会进行白盒测试。其他测试会在稍后时间由其他测试团体以黑盒或灰盒技术进行，不过有时会同时进行。 Beta (外部测试版)Beta取自希腊字母中的第二个字母“β”，表示软件测试阶段的第二个大的版本。 Beta版本是软件最早对外公开的软件版本，由公众参与测试。一般来说，Beta包含所有功能，但可能有一些已知问题和较轻微的BUG。Beta版本的测试者通常是软件开发组织的用户或者客户，他们会以免费或优惠价钱得到软件。Beta版本也被用作查看市场的反馈和用户的建议的一个版本。 其他情况，例如微软曾以Community Technology Preview（简称CTP，中文称为“社区技术预览”）为发布软件的测试版本之一，微软将这个阶段的软件散布给有需要先行试用的用户或厂商，并收集这些人的使用经验，以便作为进一步修正软件的参考。 Release Candidate, RCRelease Candidate（简称RC）指可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。在此阶段的产品通常包含所有功能、或接近完整，亦不会出现严重问题。 多数开源软件会推出两个RC版本，最后的RC2则成为正式版本。闭源软件较少公开使用，微软公司在Windows 7上应用此名称。苹果公司把在这阶段的产品称为“Golden Master Candidate”（简称GM Candidate），而最后的GM即成为正式版本。再比如，React 16就有两个RC版本，分别是Release 16.0.0-rc.1以及Release 16.0.0-rc.2。 当然，也有些软件厂商继续采用希腊字母来表示这一阶段的版本号，例如γ(gamma)，δ(delta)。 发布阶段Release to Manufacting, RTM生产商发放（Release to Manufacturing，缩写RTM）是软件产品准备交付时使用的术语。某些计算机程序以“RTM”作为软件版本代号，例如微软Windows 7发行零售版前的RTM版本主要是发放给组装机生产商用，使制造商能够提早进行集成工作或解决软件与硬件设备可能遇到的错误。RTM版本并不一定意味着创作者解决了软件所有问题；仍有可能向公众发布前更新版本。以Windows 7为例：RTM版与零售版的版本号是一样的。 General availability, GA一般可用（General availability, 缩写GA）是所有必要的商业活动已经完成，该软件产品已经可以发售的阶段。然而，这取决于语言、地域和电子设备与媒体的可用性。商业活动可能也包括安全性和合法测试，以及本地化和全球销售的可能性评估。RTM与GA的间隔可能会是1周或几个月，因为在此过程中需要进行许多商业活动·。在这个阶段，可以说软件已经“上线”了。 Release to Web, RTW网络分发（Release to Web，缩写RTW），或称Web发布是一种利用互联网进行分发的软件交付方式。制造商在这种类型的发布中并不生产实体软件。随着互联网使用人数的增长，RTW变得越来越普遍。 参考文档本篇文章大部分来自维基百科的内容。 http://blog.csdn.net/linxinzheng/article/details/2201043 https://en.wikipedia.org/wiki/Software_release_life_cycle https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://blog.maple-yf.com/tags/IT/"}]},{"title":"Jest自动化测试简介","slug":"2018-01-08-jest-introduction","date":"2018-01-07T16:00:00.000Z","updated":"2020-03-05T03:55:35.780Z","comments":true,"path":"2018/01/08/2018-01-08-jest-introduction/","link":"","permalink":"http://blog.maple-yf.com/2018/01/08/2018-01-08-jest-introduction/","excerpt":"","text":"简介Jest 被 Facebook 用来测试包括 React 应用在内的所有 JavaScript 代码。Jest 的一个理念是提供一套完整集成的 “零配置” 测试体验。 基础测试通过test和expect函数来完成一次最简单的测试： const sum = require('./sum'); test('adds 1 + 2 to equal 3', () => { expect(sum(1, 2)).toBe(3); }); 如果sum函数返回的值就行我们测试描述的那样是3的话，测试通过。 结合enzymeenzyme是aribnb开源的一套测试React的库。它提供的mount方法可以模拟React里的render生成对应的DOM字符串，另外还提供了类似simulate的方法用来模拟事件操作。比如下边的测试例子： it(\"should provide the actions and subscribe to changes\", () => { store.setState({ count: 0 }) const Comp = ({ count, increment }) => ( &lt;h1 onClick={increment}>{count}&lt;/h1> ) const mapToProps = ({ count }) => ({ count }) const actions = store => ({ increment: state => ({ count: state.count + 1 }) }) const ConnectedComp = connect(mapToProps, actions)(Comp) const App = () => ( &lt;Provider store={store}> &lt;ConnectedComp /> &lt;/Provider> ) const wrapper = mount(&lt;App />) expect(wrapper.html()).toBe(\"&lt;h1>0&lt;/h1>\") wrapper.children().simulate(\"click\") wrapper.children().simulate(\"click\") expect(wrapper.html()).toBe(\"&lt;h1>2&lt;/h1>\") }) 使用mount方法模拟render，通过html方法把DOM结构转换成字符串，通过simulate来模拟单击事件。从而完成整个测试用例。 快照测试enzyme里提供的方法都是基于React的，但是对于类React库而言，这些并不能使用比如Rax。不过，Jest提供了一种快照测试，可以通过快照的方式这是render后的DOM结构。 快照测试是通过记录React结构树快照或其他可序列化的值，来简化 Ui 测试，并分析state如何随时间变化而改变。 一个典型的快照测试案例是，为移动端应用的UI组件截个图，和需要测试参考图进行比较。如果两张图片不一致，说明测试不通过：可能是非法修改造成的，也可能是UI组件未及时render造成的。 Jest Snapshot在测试react组件时，也可以采用相同的思路进行快照测试。只不过，我们不是通过截图对比，而是保存render时所生成的序列化React tree。例如： import React from 'react'; import Link from '../Link.react'; import renderer from 'react-test-renderer'; it('renders correctly', () => { const tree = renderer .create(&lt;Link page=\"http://www.facebook.com\">Facebook&lt;/Link>) .toJSON(); expect(tree).toMatchSnapshot(); }); 生成 snapshot file第一次运行该测试脚本时，Jest会自动生成一个 snapshot file，路径默认是 ./__snapshot__。文件内容如下所示： exports[`renders correctly 1`] = ` &lt;a className=\"normal\" href=\"http://www.facebook.com\" onMouseEnter={[Function]} onMouseLeave={[Function]} > Facebook &lt;/a> `; 之后再次运行测试脚本的时候，Jest会自动比对render输出的结果和之前的snapshot file的差异，如果相同，则测试通过。 更新 snapshot file由于每次运行结果都会和第一次的 snapshot file 进行比对，如果我想更换比对的 snapshot file文件内容，应该怎么办呢？ 首先，假如我们有如下场景，更换前面的Link组件的链接，代码如下： import React from 'react'; import Link from '../Link.react'; import renderer from 'react-test-renderer'; it('renders correctly', () => { const tree = renderer .create(&lt;Link page=\"http://www.instagram.com\">Facebook&lt;/Link>) .toJSON(); expect(tree).toMatchSnapshot(); }); 这时，运行测试脚本时，测试失败。因为render出的快照结果和本次存储的初次 snapshot file内容不一致。此时，如果我想把本次的render结果作为 snapshot file的内容供以后测试比对，可以运行一下命令进行更新： jest --updateSnapshot rax-test-renderer针对Rax测试，官方提供了一个对应的npm包，rax-test-renderer。 利用它提供的renderer替换react的renderer就可以对rax进行快照测试了。 异步测试使用Jest进行异步测试，有以下三种方式。 assertions通过断言的方式进行测试，所调用的异步方法必须返回一个promise对象。 it('works with promises', () => { expect.assertions(1); return user.getUserName(4).then(data => expect(data).toEqual('Mark')); }); async/await使用这种方式，更显得简单一些，可以和之前的同步测试一样的思路写测试用例。只不过，在异步方法前边加上await关键字用来表示异步执行。 it('works with async/await', async () => { expect.assertions(1); const data = await user.getUserName(4); expect(data).toEqual('Mark'); }); donedone是异步测试的一种弥补方式，如果需要测试的异步方法没办法返回promise或者不方便转换成async/await的写法，可以通过done方法来实现这种场景的异步测试。 test('the data is peanut butter', done => { function callback(data) { expect(data).toBe('peanut butter'); done(); } fetchData(callback); }); 例如上边的例子，callback是一个异步调用，正常的测试流程下，是不会等着回调再进行测试的。所以Jest加入done方法，done方法被调用的时候，整条测试才会完成。如果done一直没有调用，则测试失败。 APIJest提供了非常丰富的测试API，一共分为以下几类。 Globals全局API：在测试工程中，这些方法或对象直接放到了全局环境中，不需要额外的引入。其中比较常用的有afterAll(fn, timeout)、afterEach(fn, timeout)、beforeAll(fn, timeout)、beforeEach(fn, timeout)，分别表示所有测试结束时调用，每个测试结束时调用，所有测试开始前调用，每个测试开始前调用。 Expect这是Jest的关键API，通过expect对象提供的方法，我们用来描述期望得到的结果。expect.toBe() expect.toEqual() expect.toMatch() expect.toMatchObject()等。 Mock Functions用来测试函数的间接调用过程，并把调用过程中的返回信息存储下来。比如测试forEach的调用过程，为传入的数组中的每个元素调用一个回调函数。 //通过jest.fn()创建供forEach调用的回调函数 const mockCallback = jest.fn(); forEach([0, 1], mockCallback); // 此模拟函数被调用了两次 //mockCallback.mock.calls中记录了每次调用的结果 expect(mockCallback.mock.calls.length).toBe(2); // 第一次调用函数时的第一个参数是 0 expect(mockCallback.mock.calls[0][0]).toBe(0); // 第二次调用函数时的第一个参数是 1 expect(mockCallback.mock.calls[1][0]).toBe(1); The Jest Objectjest是一个全局对象，在测试文件中可以直接调用。比如上边的例子中的jest.fn()。jest对象里提供了一些系统方法，可以工号的控制整个测试行为和流程。 Configuring JestJest的配置可以直接在package.json中进行设置。 \"jest\": { \"verbose\": true,/*展示详细的测试结果*/ \"moduleFileExtensions\": [ \"jsx\", \"js\" ], \"setupFiles\": [ \"&lt;rootDir>/config/testSetup.js\" /*配置入口文件*/ ], \"transformIgnorePatterns\": [ \"node_modules/(?!(FOXRax)/)\" /*不忽略node_modules中指定模块的ES6转换(默认情况下，transform转换不作用于node_modules中的模块)*/ ], \"transform\": { \"^.+\\\\.(js|jsx)$\": \"babel-jest\" /*js、jsx指定babel转换*/ }, \"testMatch\": [ \"&lt;rootDir>/src/**/*.spec.(js|jsx)\" /*测试文件匹配*/ ] }, Jest CLI OptionsJest命令行工具也提供了一些实用的选项。当然，命令行选项也可以在配置文件里设置。比如比较实用的 --json --outputFile=&lt;filename&gt; 的配合使用就可以以json的格式把测试结果输出到本地文件中。 参考文献 http://facebook.github.io/jest/docs/en/snapshot-testing.html#snapshot-testing-with-jest https://facebook.github.io/jest/docs/en/api.html","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"Auto Test","slug":"Auto-Test","permalink":"http://blog.maple-yf.com/tags/Auto-Test/"}]},{"title":"残诗","slug":"2018-01-08-residual-poem","date":"2018-01-07T16:00:00.000Z","updated":"2020-03-05T03:55:35.781Z","comments":true,"path":"2018/01/08/2018-01-08-residual-poem/","link":"","permalink":"http://blog.maple-yf.com/2018/01/08/2018-01-08-residual-poem/","excerpt":"","text":"你不经意间扣开了我的心窗点亮了一点小小的希望像深秋夜空中细细的星子美得清澈又无可奈何的渺茫","categories":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/categories/Poetry/"}],"tags":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/tags/Poetry/"}]},{"title":"模块化和Webpack入门","slug":"2018-01-07-webpack-introduce","date":"2018-01-06T16:00:00.000Z","updated":"2020-03-05T03:55:35.780Z","comments":true,"path":"2018/01/07/2018-01-07-webpack-introduce/","link":"","permalink":"http://blog.maple-yf.com/2018/01/07/2018-01-07-webpack-introduce/","excerpt":"","text":"简介本质上，webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。(摘自webpack中文文档) 模块化我们现在已经对前端的模块化习以为常了，但是，想想就在前几年，前端的模块化解决方案层出不穷。出现了各种规范和工具。所以，介绍webpack之前，先简述一下前端模块演进历史。 CommonJSCommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。 这个项目最开始是由 Mozilla 的工程师 Kevin Dangoor 在2009年1月创建的，当时的名字是 ServerJS。并于2009年8月改名为 CommonJS，以显示其 API 的更广泛实用性。 CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行。该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。 CommonJS就是为JS的表现来制定规范，因为js没有模块的功能所以CommonJS应运而生，它希望js可以在任何地方运行，不只是浏览器中。Node就是采用了CommonJS规范。 AMDAMD（Asynchronous Module Definition 异步模块定义）是为浏览器环境设计的，因为 CommonJS 模块系统是同步加载的，当前浏览器环境还没有准备好同步加载模块的条件。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 AMD 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。中文文档) CMDAMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD(Common Module Definition) 是 SeaJS 在推广过程中对模块定义的规范化产出。是玉伯大大推出的专注于浏览器的js模块加载规范。 UMDUniversal Module Definition，AMD和CommonJS的一种兼容性写法。同时支持两种风格，使AMD和CommonJS和谐相处。 ES6模块ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 安装webpack的安装非常简单，和普通的node应用一样$ npm install webpack -g即可安装。 配置跑起来简单的使用webpack还是很容易的。假如我们的文件结构是 |–index.html|–js |–data.js |–index.js|–dist/dist.js index.js里只是简单的写一句对data.js的引用例如： var data = require(\"./data\"); 直接使用webpack命令行工具： webpack js/index.js dist/dist.js 则我们可以在dist.js里看到打包后的代码，data.js也会根据引用关系打包进去。webpack的初次实践就完美的完成啦。 webpack.config.jswebpack之所以强大，只是一个简单的命令行工具是完全不够的。所以我们要借助webpack.config.js的配置来完成更加复杂的打包任务。 首先，在根目录创建package.json文件，用来配置webpack相关依赖： { \"name\": \"webpack-example\", \"version\": \"1.0.0\", \"description\": \"A simple webpack example.\", \"main\": \"bundle.js\", \"keywords\": [ \"webpack\" ], \"author\": \"maple.yf\", \"license\": \"MIT\", \"dependencies\": { \"webpack\": \"^1.12.2\" } } 其次，创建webpack.config.js文件用来配置打包信息，比如文件入口、打包输出： var webpack = require('webpack') module.exports = { entry: './js/index.js', output: { path: __dirname + '/dist', filename: 'dist.js' }, module: { rules: [] }, plugins: [ ] } 完成配置之后，在命令行中输入webpack，就和上一节中输入的webpack js/index.js dist/dist.js是一样的效果。 loaderloader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 其实，loader就是帮助webpack处理非JavaScript文件。在webpack 1.x中，是通过module.loaders来配置的，升级到webpack 2.0后，loader配置项被功能更为强大的rules取代。官方文档loader。 plugins插件被webpack官方描述为支柱性功能。它是用来解决loader无法完成的其他事情的。webpack自身提供一些插件，也有很多第三方插件可以使用。能够好好使用插件，将为我们的项目打包提供非常大的便利。将专门抽出一篇来讲解webpack插件的使用技巧。 参考资料 https://doc.webpack-china.org/concepts/ http://zhaoda.net/webpack-handbook/what-is-webpack.html https://div.io/topic/1752 http://www.ruanyifeng.com/blog/2014/09/package-management.html https://webpack.js.org/comparison/","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.maple-yf.com/tags/Webpack/"}]},{"title":"plantuml简介","slug":"2017-08-27-plantuml","date":"2017-08-26T16:00:00.000Z","updated":"2020-03-05T04:22:22.475Z","comments":true,"path":"2017/08/27/2017-08-27-plantuml/","link":"","permalink":"http://blog.maple-yf.com/2017/08/27/2017-08-27-plantuml/","excerpt":"简介最近在学习设计模式，但是在画类图的时候，有一堆的画图工具可以选择，但总感觉用的不顺手。于是在网上找到了这个神奇的语言。PlantUML是一个开源项目，支持时序图、用例图、类图、活动图、组件图、状态图、对象图等的绘制。简而言之，就是用写代码的方式画图。几行代码，输出标准结构图，不用再去考虑结构、对齐等琐事啦！ 效果预览如下简单的语法表达类图之间的关系 @startuml Class01 &lt;|-- Class02 Class03 &lt;|.. Class04 Class05 *-- Class06 Class07 o-- Class08 Class09 &lt;.. Class10 Class11 &lt;-- Class12 @enduml","text":"简介最近在学习设计模式，但是在画类图的时候，有一堆的画图工具可以选择，但总感觉用的不顺手。于是在网上找到了这个神奇的语言。PlantUML是一个开源项目，支持时序图、用例图、类图、活动图、组件图、状态图、对象图等的绘制。简而言之，就是用写代码的方式画图。几行代码，输出标准结构图，不用再去考虑结构、对齐等琐事啦！ 效果预览如下简单的语法表达类图之间的关系 @startuml Class01 &lt;|-- Class02 Class03 &lt;|.. Class04 Class05 *-- Class06 Class07 o-- Class08 Class09 &lt;.. Class10 Class11 &lt;-- Class12 @enduml 效果如下： 再看一下复杂一点的装饰者模式类图，代码如下 @startuml namespace Decorator{ interface Component interface Decorator Component : +operation():void ConcreateComponent : +opreation():void Decorator : -component:Component Decorator : +opreantion():void ConcreateDecorator1 : +opreation():void ConcreateDecorator1 : +addBehavior():void ConcreateDecorator2 : +opreation():void ConcreateDecorator2 : +addBehavior():void Decorator &lt;|-- ConcreateDecorator1 Decorator &lt;|-- ConcreateDecorator2 Component &lt;|.. Decorator Component &lt;|.. ConcreateComponent Decorator o-- Component note bottom of Decorator component.opreation(); end note note bottom of ConcreateDecorator1 super.operation(); addBehavior(); end note note bottom of ConcreateDecorator2 super.operation(); addBehavior(); end note } @enduml 效果图： 时序图长这样： @startuml title 时序图 == 鉴权阶段 == Alice -&gt; Bob: 请求 Bob -&gt; Alice: 应答 == 数据上传 == Alice -&gt; Bob: 上传数据 note left: 这是显示在左边的备注 Bob --&gt; Canny: 转交数据 ... 不超过 5 秒钟 ... Canny --&gt; Bob: 状态返回 note right: 这是显示在右边的备注 Bob -&gt; Alice: 状态返回 == 状态显示 == Alice -&gt; Alice: 给自己发消息 @enduml 环境配置这里主要介绍 Mac + VS Code + Markdown Preview Enhanced 实现PlantUML预览的配置过程 Mac环境支持plantUML的markdown编译\b步骤 brew install libtool brew link libtool brew install graphviz brew link --overwrite graphviz \b如果没有gem，先安装gem。然后执行下面语句安装 asciidoctor。 gem install asciidoctor 安装完支持环境之后，VS Code里装上 Markdown Preview Enhanced 就可以在markdown里编辑和预览效果啦！ plantuml语法：http://plantuml.com/ 目前，sublime、Atom、VS Code、Webstorm都有相对应的插件来实现在编辑器里编辑和预览plantUML。 plantuml编辑器整理这里还有一些其他的编辑器推荐。大部分都是在线预览版本，也有编辑器插件。 1、https://www.planttext.com/2、http://www.plantuml.com/plantuml3、https://sujoyu.github.io/plantuml-previewer/4、Chrome插件 UML Diagram Editor （渲染效果模糊，速度慢）5、Intellij Idea 插件（Android Studio 当然也支持）：PlantUML integration 参考 http://plantuml.com/ http://www.voidcn.com/blog/lonewolf521125/article/p-6630256.html http://www.voidcn.com/blog/linuxcjh/article/p-5799343.html","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://blog.maple-yf.com/tags/UML/"}]},{"title":"Hello World","slug":"2017-08-06-hello-world","date":"2017-08-05T16:00:00.000Z","updated":"2020-03-05T04:21:09.611Z","comments":true,"path":"2017/08/06/2017-08-06-hello-world/","link":"","permalink":"http://blog.maple-yf.com/2017/08/06/2017-08-06-hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://blog.maple-yf.com/tags/IT/"}]},{"title":"夜雨","slug":"2017-07-21-raining-night","date":"2017-07-20T16:00:00.000Z","updated":"2020-03-05T04:22:04.163Z","comments":true,"path":"2017/07/21/2017-07-21-raining-night/","link":"","permalink":"http://blog.maple-yf.com/2017/07/21/2017-07-21-raining-night/","excerpt":"","text":"雷隐隐，风悄悄这整夜的雨淅淅沥沥潇潇","categories":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/categories/Poetry/"}],"tags":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/tags/Poetry/"}]},{"title":"前端编程利器VS Code","slug":"2017-07-20-vscode-introduction","date":"2017-07-19T16:00:00.000Z","updated":"2020-03-05T04:38:56.123Z","comments":true,"path":"2017/07/20/2017-07-20-vscode-introduction/","link":"","permalink":"http://blog.maple-yf.com/2017/07/20/2017-07-20-vscode-introduction/","excerpt":"","text":"前言前端同学使用的编辑器可选范围非常广泛。 最开始接触到前端的时候，听说了Dreamweaver这么一个强大的软件，但严格意义上讲，这不能算作一个编辑器。后来认识了NotePad++，在当时，这确实是一款非常好用的编辑器，语法高亮的友好度仅次于IDE，而且占用内存小，运行非常流畅。 再然后，有人推荐Sublime。我用的时候，还是Sublime 2，最吸引我的是它的mini map，拖动mini map快速浏览大段大段的代码，比拖动小小的滑块酸爽很多呀。再加上后来安装的各种插件，感觉我进入了一个全新的世界，Sublime才是我最想用的编辑器呀！ 工作之后，听说大家都在用webstorm，于是我也安装了一个试试，功能确实强大，特别它自带的git管理以及编辑器内部打开terminal的功能，非常适合前端开发。但是，功能强大的webstorm太过于笨重，每次打开的时候都要等一会儿，占用内存太高，同时开启两个项目的时候，电脑就会特别卡，非常影响写代码的心情，而且，webstorm是收费软件，用了一段时间之后果断放弃。 这时，我尝试了一款觊觎已久的酷炫编辑器 Atom。用了Atom之后，我才知道了什么叫酷炫！Sublime算什么，我再也不要用那个丑丑的Sublime了。基于Electron)（最初以Atom Shell知名）和许可使用Chromium和Node.js的跨平台应用框架，并使用CoffeeScript和Less)编写。Atom不但酷炫而且强大，因为有着活跃的社区，所以插件非常多，除了满足开发的刚需之外，还有很多想都想不到的插件。但是但是，美中不足的是Atom太卡了，而且用的时候偶尔还会崩溃。坚持用了一个月，最后实在受不了，我又换回Sublime了，但是心中很不甘啊！ 当时我就想着，如果有一款编辑器可以像Sublime一样流程同时又像Atom一样酷炫该有多好。于是，我遇到了VS Code。VS Code刚刚发布Beta版时我尝试着用过一次，当时还不稳定，社区也不完善，插件更是贫乏，所以没留下好印象。这次重新尝试，是因为听说它和Atom一样，也是通过Electron编写的，我想，至少可以像Atom一样酷炫吧。试用之后才发现，原来这才是我一直苦苦寻找的理想编辑器呀！ 特性我强烈推荐VS Code的原因是它有以下几大特点： 酷炫 和Atom一样采用Electron框架编写，整个软件其实就是一个WebAPP，样式深度定制，酷炫到超乎你想象。如果觉得还不过瘾，可以自己编写theme插件，满足你的各种癖好。 轻量 虽然同样是采用Electron框架编写，但是VS Code和Atom走了不同的路线。Atom从一开始就把插件化架构摆在第一位，所以，Atom中最重要的是灵活而又完备的API，性能则不那么重要。VS Code则是把用户体验放在第一位，高性能、更能丰富才是它的首要目的，所以，一开始VS Code的插件系统很糟糕。但是VS Code的性能绝对高出Atom一个档位。 开源 继承了Electron的良好基因。 跨平台 依然是继承了Electron的良好基因。 丰富的插件 虽然不如Sublime和Atom数量多，但现在已经有越来越多的插件涌入。 活跃的社区 得益于Electron和Atom，VS Code的社区也是非常的活跃，更加快了插件生态的繁荣。 自带功能EmmetVS Code不需要安装插件，自身就实现了Emmet，默认就是打开的。 智能感知VS Code本身自带JS代码提示和自动补全功能，当然，如果你觉得不够用，还可以安装各种intelligence或者snippets插件来满足需求。 Format Document对于压缩的代码，或者格式不够规范的代码文件，可以通过这个命令一键格式化代码。当然，这个功能是每个编辑器应该都有的，并不是亮点。 Auto Save自动保存功能也是大部分优秀的编辑器应该必备的。我认为VS Code里做的比较人性化的一个点是，它的设置选项里提供了四种自动保存的时机供我们选择：off、afterDelay、onFocusChange(编辑器失去焦点)、onWindowChange(窗口失去焦点)。如果设置为afterDelay，则可在 files.autoSaveDelay 中配置延迟。我比较喜欢onWindowChange。 TerminalVS Code自带打开Terminal的功能，这是Atom和Sublime所不具备的。这也算是VS Code的一大亮点。 插件推荐接下来，推荐一些我用到过的非常实用的插件，帮助你编程时候事半功倍！ Git History 可以查看一个文件的所有提交记录，同时还可以调出一个可视化的界面展示文件的提交记录，是git log的强化版。还可以查看某一行的所有提交记录。 Git Peoject Manager这是一个git项目管理的插件，一共就4个命令： GPM: Open Git Project (Ctrl+Alt+P)：打开git项目 GPM: Refresh Projects：刷新git项目 GPM: Refresh specific project folder：刷新特定路径下的git项目 GPM: Open Recent Git Project (Ctrl+Shift+Q)：最近打开的git项目列表 插件的使用也很简单，找到配置文件中gitProjectManager.baseProjectsFolders把git项目的根目录放进去，就像下边这样：{ &quot;gitProjectManager.baseProjectsFolders&quot;: [ &quot;/home/user/nodeProjects&quot;, &quot;/home/user/personal/pocs&quot; ] } 然后cmd + shift + P调出命令栏，并输入GPM，上述的4个命令就被列出来了，选择Refresh Projects，稍等一会儿后，被我们添加到配置文件里的路径下的所有git项目都会被列出来。选择你的工作目录开始Coding吧！ Git Lens这是一款非常强大的git插件，它提供的每一个功能，都戳中了我们日常开发中的需求痛点。所以，我强烈推荐大家安装并使用这款插件。先目睹一下它的功能概览gif图： Code Lens在文件的顶部展示代码变更的总的记录，包括左边的最新修改记录以及右边的所有的修改作者数量。 Blame Annotations点击右边的作者数量可以进入整个文件的Blame Annotations。这里展示了每一行的最后一条修改记录，具体的展示方式可以在设置里自己配置，包括作者、时间和commit信息。 Status Bar Blame这个是指在状态栏里展示当前光标所在行的Git Blame信息。当然这里要展示的信息和格式也是可以配置的。这样，光标所在的行的最新git记录和作者信息完全展示在了状态栏里。 Interactive Blame这个功能和Status Bar Status类似，只不过，git信息是直接展示在文件中的代码后边。鼠标悬停在git记录上时，会有更详细的git变更气泡弹出。就像下边这样： Quick Menu快捷键shift + alt + H调出branch history quick pick menu， 这个菜单功能非常强大，我们可以查看之前的commits信息、所有commits信息、根据message/author/filename搜索commits信息、查看一些文件的历史记录等。 通过message查找时，直接在输入框里输入message的关键信息即可。通过author查找时，则是输入@author，类似于图中的@Zeke。而通过filename查找，则需要注意一下，这里应该是: filepath，也就是相对于当前项目根目录的相对路径。类似于图中的:lib/browser/chrome-extension.js。除了这些之外，还可以根据commit id查找，这个用的不多，这里就不再举例了。 Project Manager项目管理插件，这个功能和Git Project Manager有点类似，只不过，这个不但能管理git项目，还可以管理其他项目。 这个插件一共5个命令： Project Manager: Edit Project Edit 跳转到配置文件 projects.json 进行项目列表目录的配置修改。 Project Manager: List Projects 列出已经保存的项目列表。 Project Manager: List Projects to Open in New Window 列出已保存的项目列表并在新窗口打开选中的项目。 Project Manager: Refresh Projects 刷新项目列表。 Project Manager: Save Project 保存当前项目到项目列表。 其他插件其他的一些插件就不做详细介绍了，这里列出我用过的感觉比较好的，大家自己到github上查阅吧。vscode-icons、vscode-fileheader、Document This、CSS Peek、File Peek、Markdown PDF、Markdown Preview Enhanced、Regex Railroad Diagrams。 如果还有其他比较好用或者有意思的插件，欢迎大家前来留言。一起讨论交流。","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"VS Code","slug":"VS-Code","permalink":"http://blog.maple-yf.com/tags/VS-Code/"}]},{"title":"南湖向晚","slug":"2017-07-09-south-lake-at-dusk","date":"2017-07-08T16:00:00.000Z","updated":"2020-03-05T03:55:35.778Z","comments":true,"path":"2017/07/09/2017-07-09-south-lake-at-dusk/","link":"","permalink":"http://blog.maple-yf.com/2017/07/09/2017-07-09-south-lake-at-dusk/","excerpt":"","text":"没有偶遇记忆中雨后的彩虹这里清清静静悄悄依旧于是晚霞偷偷染红了半边天空故地重游的喜悦总伴着物是人非的惆怅回忆也显得那么美那么伤那么无可奈何的凄凉每一次心心念念的感慨都装入成长路上破旧的行囊变与不变的留恋都化作或甜或苦的记忆珍藏再次回归的少年依旧因为我从未离开不曾遗忘","categories":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/categories/Poetry/"}],"tags":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/tags/Poetry/"}]},{"title":"趁黄昏","slug":"2017-05-08-dusk","date":"2017-05-07T16:00:00.000Z","updated":"2020-03-05T03:55:35.778Z","comments":true,"path":"2017/05/08/2017-05-08-dusk/","link":"","permalink":"http://blog.maple-yf.com/2017/05/08/2017-05-08-dusk/","excerpt":"","text":"十里春风独爱这柳树的枝头趁黄昏，走一走晚风亲吻着温柔一次日落偏好那静静的巷口趁黄昏，等一等夕阳西下的守候","categories":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/categories/Poetry/"}],"tags":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/tags/Poetry/"}]},{"title":"吹雪","slug":"2017-02-07-snow","date":"2017-02-06T16:00:00.000Z","updated":"2020-03-05T04:39:14.072Z","comments":true,"path":"2017/02/07/2017-02-07-snow/","link":"","permalink":"http://blog.maple-yf.com/2017/02/07/2017-02-07-snow/","excerpt":"","text":"我经历了一次美丽的邂逅是这突如其来的吹雪轻轻吻向泥土的等候洁白在灯光交汇下漫天轻柔伴着人们心满意足的步调目睹了一对对静静地走到白头","categories":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/categories/Poetry/"}],"tags":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/tags/Poetry/"}]},{"title":"不得不说再见","slug":"2016-06-25-say-goodbye","date":"2016-06-24T16:00:00.000Z","updated":"2020-03-05T04:41:37.719Z","comments":true,"path":"2016/06/25/2016-06-25-say-goodbye/","link":"","permalink":"http://blog.maple-yf.com/2016/06/25/2016-06-25-say-goodbye/","excerpt":"","text":"终于这宴席还是要散场请不要为我鼓掌也不要欢送潺潺的流水在为我歌唱盛放的蔷薇散发着芬芳河边的杨柳也在轻轻地飘荡夏天总因离别变得黯然惆怅还想再听一听丰富多彩的课堂还想再逛一逛青春洋溢的操场还想再聊一聊槽点满满的旧日时光还想，还想……别了校园，别了矿大别了那逝去的青春模样南湖上升起的月光请替我守护这片温馨的土壤我在下一个路口等待青春不散场","categories":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/categories/Poetry/"}],"tags":[{"name":"Poetry","slug":"Poetry","permalink":"http://blog.maple-yf.com/tags/Poetry/"}]},{"title":"安装静态博客Jekyll","slug":"2016-04-29-jekyll-install","date":"2016-04-28T16:00:00.000Z","updated":"2020-03-05T04:39:34.206Z","comments":true,"path":"2016/04/29/2016-04-29-jekyll-install/","link":"","permalink":"http://blog.maple-yf.com/2016/04/29/2016-04-29-jekyll-install/","excerpt":"Jekyll是一种纯文本的静态博客，安装成功之后，直接通过markdown文本就可以更新博客内容。Jekyll的安装过程比较简单，但是安装的过程中仍然会跳进很多坑。Jekyll和Github Pages是一种很好的结合。Github Pages是github提供的一个可以免费部署个人网站且没有存储上限的一个功能。在Jekyll的官网里也有把Jekyll部署到Github Pages上的教程。 安装Jekyll如果需要部署到Github Pages，Jekyll需要在本地完成安装，然后再进行部署。Jekyll的安装智能在Linux和Mac OS X上进行，另外，其依赖Ruby和RubyGems，建议安装rvm来控制Ruby的版本。Linux和Mac OS X一般都会有系统自带的Ruby，但是版本比较旧，通过 ruby -v","text":"Jekyll是一种纯文本的静态博客，安装成功之后，直接通过markdown文本就可以更新博客内容。Jekyll的安装过程比较简单，但是安装的过程中仍然会跳进很多坑。Jekyll和Github Pages是一种很好的结合。Github Pages是github提供的一个可以免费部署个人网站且没有存储上限的一个功能。在Jekyll的官网里也有把Jekyll部署到Github Pages上的教程。 安装Jekyll如果需要部署到Github Pages，Jekyll需要在本地完成安装，然后再进行部署。Jekyll的安装智能在Linux和Mac OS X上进行，另外，其依赖Ruby和RubyGems，建议安装rvm来控制Ruby的版本。Linux和Mac OS X一般都会有系统自带的Ruby，但是版本比较旧，通过 ruby -v 可以查看当前Ruby的版本。当前Github Pages支持的是Jekyll 3.0，其依赖的Ruby 2.0及其以上版本，所以建议安装Ruby 2.0或其以上版本。 本次安装，我是直接从github上找了一个别人做好的带主题的Jekyll，然后安装在自己的VPS上了，这个Jekyll Theme的名字叫做Personal，把它git到我vps上之后，通过一个命令就可以安装完成： ./scripts/install 它对Ruby的需求是2.0及其以上版本，否则会安装失败。 配置安装成功之后，需要对_config.yml文件进行一些个性配置。具体配置可以参考项目中的教程。主要的配置有以下几个： url:这个是用来指向自己的域名(如果你有的话)，配置到Github Pages上并指向自己的域名或者二级域名可以参考github官方教程 baseurl:用来设置自己网站的相对根目录，我设置的是空，因为在我的Github Pages中的这个项目是直接放在根目录下的 force-https:这个配置是原版Jekyll没有的，这里建议设置为false，因为Github Pages目前既支持http也支持https，如果自己没有https的证书的话，还是把其关闭的好 其余的配置都可以参考personal项目中的教程。 部署配置完成之后，就可以部署到Github Pages中了，我直接把安装好的整个文件夹push到了github中。在push之前，需要先创建自己的Github Pages，每一个github用户只能创建一个Github Pages，这里是官方创建教程。创建完成之后，把自己的文件push到根目录下，就可以通过 http://gitusername.github.io 访问了，如果设置了个人的域名，则需要到自己的域名管理网站更新域名指向，把设置的域名指向 http://gitusername.github.io 即可。需要注意的是，把自己的项目文件push到github之后，也许并不能立刻就访问到网页，也许是因为github内部需要一段时间的部署。我当时部署到github之后，立刻访问得到的是404页面，刚开始以为是自己配置出错了，过滤几个小时之后，再次访问，页面才第一次呈现。","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"http://blog.maple-yf.com/tags/Jekyll/"}]},{"title":"Ubuntu用户设置","slug":"2015-12-01-Setting-Ubuntu-User","date":"2015-12-01T04:00:00.000Z","updated":"2020-03-05T03:55:35.776Z","comments":true,"path":"2015/12/01/2015-12-01-Setting-Ubuntu-User/","link":"","permalink":"http://blog.maple-yf.com/2015/12/01/2015-12-01-Setting-Ubuntu-User/","excerpt":"最近在安装实验室一台服务器，系统装的是Ubuntu 14.04，今天在添加用户的时候出了点小问题，在这里总结一下。 为Ubuntu添加新用户在网上查到为Ubuntu填加新用户的方式是 sudo useradd me和passwd me来设置，但是，这样设置有一个很大的坑，因为这样设置的用户信息是不全的，直接导致使用这种方式设置的用户在进行远程登陆的时候，会出现 Could not chdir to home directory /home/me: No such file or directory 的错误，可以用过输入 bash 来进入正常的状态 $ bash me@server:/$","text":"最近在安装实验室一台服务器，系统装的是Ubuntu 14.04，今天在添加用户的时候出了点小问题，在这里总结一下。 为Ubuntu添加新用户在网上查到为Ubuntu填加新用户的方式是 sudo useradd me和passwd me来设置，但是，这样设置有一个很大的坑，因为这样设置的用户信息是不全的，直接导致使用这种方式设置的用户在进行远程登陆的时候，会出现 Could not chdir to home directory /home/me: No such file or directory 的错误，可以用过输入 bash 来进入正常的状态 $ bash me@server:/$ 为了解决这个问题，其实就是修改用户的默认shell为bash。去Google了一番，终于找到解决方案：http://askubuntu.com/questions/28969/how-do-you-change-the-default-shell-for-all-users-to-bash。方法就是，如果是root用户： usermod -s /bin/bash USERNAME 如果不是root用户： sudo -u USERNAME chsh -s /bin/bash 走过这个坑之后，建议以后添加用户，换成另外一种方式， sudo adduser me，这样虽然麻烦一些，但是权限和信息都是更加完整的。 为用户添加root权限为了能使用root权限，又去搜索了一遍如何为用户添加root权限，这里有一篇文章讲解的很详细http://blog.csdn.net/dreamback1987/article/details/8766302。这里的关键点就是在修改 /etc/sudoers文件前，需要修改它的权限，改完保存之后，再把文件权限修改回来，因为如果 /etc/sudoers 文件的权限为 777 的话，sudo命令就不能使用了。 root用户和普通用户来回切换因为本人菜鸟一枚，这里记录一下刚刚学到的一个小命令，就是root用户和普通用户的来回切换： $su root #切换到root用户 $su me #切换到me用户","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.maple-yf.com/tags/Ubuntu/"}]},{"title":"安装 ShadowScoks","slug":"2015-11-12-shadowsocks","date":"2015-11-12T07:30:00.000Z","updated":"2020-03-05T03:55:35.776Z","comments":true,"path":"2015/11/12/2015-11-12-shadowsocks/","link":"","permalink":"http://blog.maple-yf.com/2015/11/12/2015-11-12-shadowsocks/","excerpt":"ShadowScoks是一个非常易用的翻墙工具，把它安装在自己的VPS上，就可以随心所欲的上网啦！ 安装输入su进入root。分别复制以下命令到命令行： wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log","text":"ShadowScoks是一个非常易用的翻墙工具，把它安装在自己的VPS上，就可以随心所欲的上网啦！ 安装输入su进入root。分别复制以下命令到命令行： wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 执行最后一条命令之后，出现一下界面： 输入密码即可。并回车，再次回车，确认安装。 安装失败，出现错误提示： ./shadowsocks.sh: line 111: 6396 Segmentation fault (core dumped) apt-get -y update Reading package lists..../shadowsocks.sh: line 111: 6461 Segmentation fault (core dumped) apt-get -y install python python-dev python-pip curl wget unzip gcc swig automake make perl cpio 分别执行 (core dumped)后面的语句 apt-get -y update apt-get -y install python python-dev python-pip curl wget unzip gcc swig automake make perl cpio 然后，重新执行: ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 等待5分钟左右，即可安装成功，安装成功之后就会通过屏幕输出，您的IP地址，端口，密码，及加密方式。 如果您想多用户使用，请配置 /etc/shadowsocks.json 这个文件。配置模版： { \"server\":\"your_server_ip\", \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"port_password\":{ \"8989\":\"password0\", \"9001\":\"password1\", \"9002\":\"password2\", \"9003\":\"password3\", \"9004\":\"password4\" }, \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false } Windows客户端下载地址：https://shadowsocks.org/en/download/clients.html使用教程：http://wiki.ssnode.co/index.php?option=com_content&amp;view=article&amp;id=4:about-your-home-page&amp;catid=9&amp;Itemid=101使用shadowsocks时，必须要通过SSH连接上自己的VPS后才能代理成功。","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"ShadowSocks","slug":"ShadowSocks","permalink":"http://blog.maple-yf.com/tags/ShadowSocks/"}]},{"title":"win10右键反应缓慢","slug":"2015-11-07-win10-menucontext","date":"2015-11-07T03:00:00.000Z","updated":"2020-03-05T03:55:35.775Z","comments":true,"path":"2015/11/07/2015-11-07-win10-menucontext/","link":"","permalink":"http://blog.maple-yf.com/2015/11/07/2015-11-07-win10-menucontext/","excerpt":"","text":"最近装了win10，但是有一个小问题，右击电脑空白处想刷新的时候，反应特别慢，因为系统是安装在固态硬盘上的，所以不应该出现这种问题，于是网上搜罗了一些解决方法。 解决方案开始，运行：regedit，打开注册表 HKEY_CLASSES_ROOT/Directory/Background/shellex/ContextMenuHandlers 删除下面两个选项就可以了：一个是 igfxcui ,另外一个是NvCplDesktopContext如果只有一项就单独删除，如果两项都有就全部删除。","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.maple-yf.com/tags/Windows/"}]},{"title":"为笔记本（华硕A46C）更换SSD全过程","slug":"2015-09-29-replacement-of-SSD","date":"2015-09-29T03:23:32.000Z","updated":"2020-03-05T03:55:35.775Z","comments":true,"path":"2015/09/29/2015-09-29-replacement-of-SSD/","link":"","permalink":"http://blog.maple-yf.com/2015/09/29/2015-09-29-replacement-of-SSD/","excerpt":"前两天给自己的笔记本换了个SSD。我的笔记本是华硕A46C，2013年买的，属于超薄本。当时买的时候选的是无光驱版，因此光驱位就是一个空盒子。下图中左边的就是光驱位的空盒子。在换SSD的时候，需要买一个和这个盒子差不多形状的硬盘盒装上。我是把原来的机械硬盘放到了光驱位，然后把SSD放到了原来的机械硬盘（主硬盘）的位置，据说是主硬盘的位置能够提供更高的读取速度，我没有去查华硕这个系列的光驱位提供的接口，但是主硬盘的读取速度肯定不会低于光驱位，所以就这么换了，虽然麻烦了一些。","text":"前两天给自己的笔记本换了个SSD。我的笔记本是华硕A46C，2013年买的，属于超薄本。当时买的时候选的是无光驱版，因此光驱位就是一个空盒子。下图中左边的就是光驱位的空盒子。在换SSD的时候，需要买一个和这个盒子差不多形状的硬盘盒装上。我是把原来的机械硬盘放到了光驱位，然后把SSD放到了原来的机械硬盘（主硬盘）的位置，据说是主硬盘的位置能够提供更高的读取速度，我没有去查华硕这个系列的光驱位提供的接口，但是主硬盘的读取速度肯定不会低于光驱位，所以就这么换了，虽然麻烦了一些。 因为一般的光驱位硬盘盒和华硕的这个系列笔记本的边缘不太一致，导致装进去之后会凹进去一块，很难看。但是在淘宝上搜华硕A46硬盘架根本找不到，后来在网上看到有别人的更换教程，发现华硕的X450、X550系列的硬盘架能够完美适配华硕A46系列。 拆机过程如下：首先按照下图的方向把后盖拆掉 露出主硬盘 我买的这款三星250G SSD 感觉还是不错的，手机上买的589元。在天猫上买的，第一次发货之后，两三天没有更新快递信息，感觉是中通快递给弄丢了，卖家联系快递也没有消息，不过老板还是比较有业界良心的，直接重新发了一款并更换了快递。 看一下机械硬盘和固态硬盘的对比照，此时固态硬盘已经装在了主硬盘的外壳里了。 下图是装上硬盘托架之后的光驱位外边缘，这个硬盘托架还是比较合适的，就是有点贵。SSD装好之后，在里边装了win10，但是在win10里总是找不到原来的机械硬盘。进到UEFI里边是能看到的，说明硬盘托架的接口没问题，后来我尝试从机械硬盘启动，发现可以正常使用，而且在原来的系统里也能看到SSD的盘符。然后我又切回到SSD启动，机械硬盘居然神奇的出现了，并且一切使用都是正常的，我也不知道为什么，总之，这次的SSD更换也算是成功了！","categories":[{"name":"Tech","slug":"Tech","permalink":"http://blog.maple-yf.com/categories/Tech/"}],"tags":[{"name":"SSD","slug":"SSD","permalink":"http://blog.maple-yf.com/tags/SSD/"}]}]}